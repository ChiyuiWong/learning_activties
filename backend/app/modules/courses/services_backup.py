"""
COMP5241 Group 10 - Courses Module Services
Responsible: Keith
Enhanced with comprehensive teacher tools and course management features
"""
from .models import (
    Course, CourseEnrollment, CourseModule, CourseAnnouncement, 
    CourseMaterial, StudentImportLog, ImportError, MaterialDownloadLog,
    StudentInfo
)
from datetime import datetime
from mongoengine import Q
import csv
import io
import os
import uuid
from werkzeug.utils import secure_filename


class CourseService:
    """Service class for course operations with enhanced teacher tools"""
    
    @staticmethod
    def create_course(title, description, course_code, instructor_id, instructor_name=None, **kwargs):
        """Create new course with comprehensive features"""
        try:
            # Check if course code already exists
            if Course.objects(course_code=course_code).first():
                return {'success': False, 'error': 'Course code already exists'}
            
            course_data = {
                'title': title,
                'description': description,
                'course_code': course_code,
                'instructor_id': instructor_id,
                'instructor_name': instructor_name or 'Unknown',
                'category': kwargs.get('category', ''),
                'difficulty_level': kwargs.get('difficulty_level', 'beginner'),
                'max_students': kwargs.get('max_students', 100),
                'semester': kwargs.get('semester', ''),
                'university': kwargs.get('university', ''),
                'start_date': kwargs.get('start_date'),
                'end_date': kwargs.get('end_date'),
                'is_published': kwargs.get('is_published', False),
                'lms_integration': kwargs.get('lms_integration', {}),
                'sync_with_lms': kwargs.get('sync_with_lms', False)
            }
            
            course = Course(**course_data)
            course.save()
            
            return {'success': True, 'course': course}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    @staticmethod
    def get_courses_by_instructor(instructor_id, page=1, per_page=20, filters=None):
        """Get courses by instructor with pagination and filtering"""
        try:
            query = Q(instructor_id=instructor_id)
            
            # Apply filters
            if filters:
                if filters.get('is_active') is not None:
                    query &= Q(is_active=filters['is_active'])
                if filters.get('is_published') is not None:
                    query &= Q(is_published=filters['is_published'])
                if filters.get('category'):
                    query &= Q(category=filters['category'])
                if filters.get('semester'):
                    query &= Q(semester=filters['semester'])
                if filters.get('search'):
                    search = filters['search']
                    query &= (Q(title__icontains=search) | Q(course_code__icontains=search))
            
            # Calculate offset
            offset = (page - 1) * per_page
            
            # Get total count
            total = Course.objects(query).count()
            
            # Get courses
            courses = Course.objects(query).order_by('-created_at').skip(offset).limit(per_page)
            
            return {
                'success': True,
                'courses': courses,
                'pagination': {
                    'page': page,
                    'per_page': per_page,
                    'total': total,
                    'pages': (total + per_page - 1) // per_page
                }
            }
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    @staticmethod
    def get_course_by_id(course_id, include_stats=False):
        """Get specific course by ID with optional statistics"""
        try:\n            course = Course.objects(id=course_id).first()\n            if not course:\n                return {'success': False, 'error': 'Course not found'}\n            \n            result = {'success': True, 'course': course}\n            \n            if include_stats:\n                # Get enrollment statistics\n                enrollments = CourseEnrollment.objects(course_id=str(course.id))\n                stats = {\n                    'total_enrolled': enrollments.count(),\n                    'active_students': enrollments.filter(status='enrolled').count(),\n                    'completed': enrollments.filter(status='completed').count(),\n                    'dropped': enrollments.filter(status='dropped').count(),\n                    'materials_count': CourseMaterial.objects(course_id=str(course.id)).count(),\n                    'announcements_count': CourseAnnouncement.objects(course_id=str(course.id)).count()\n                }\n                result['stats'] = stats\n            \n            return result\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def update_course(course_id, instructor_id, update_data):\n        """Update course (only by instructor)\"\"\"\n        try:\n            course = Course.objects(id=course_id, instructor_id=instructor_id).first()\n            if not course:\n                return {'success': False, 'error': 'Course not found or access denied'}\n            \n            # Update allowed fields\n            allowed_fields = [\n                'title', 'description', 'category', 'difficulty_level', 'max_students',\n                'semester', 'university', 'start_date', 'end_date', 'is_published',\n                'lms_integration', 'sync_with_lms'\n            ]\n            \n            for field in allowed_fields:\n                if field in update_data:\n                    setattr(course, field, update_data[field])\n            \n            course.save()\n            return {'success': True, 'course': course}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def delete_course(course_id, instructor_id):\n        \"\"\"Soft delete course (only by instructor)\"\"\"\n        try:\n            course = Course.objects(id=course_id, instructor_id=instructor_id).first()\n            if not course:\n                return {'success': False, 'error': 'Course not found or access denied'}\n            \n            course.is_active = False\n            course.save()\n            return {'success': True, 'message': 'Course deactivated successfully'}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n\n\nclass EnrollmentService:\n    \"\"\"Service class for enrollment operations with bulk import support\"\"\"\n    \n    @staticmethod\n    def enroll_student(course_id, student_id, student_name=None, student_email=None, **kwargs):\n        \"\"\"Enroll single student in course\"\"\"\n        try:\n            # Check if course exists and has capacity\n            course = Course.objects(id=course_id).first()\n            if not course:\n                return {'success': False, 'error': 'Course not found'}\n            \n            if course.current_enrollment >= course.max_students:\n                return {'success': False, 'error': 'Course is full'}\n            \n            # Check if already enrolled\n            existing = CourseEnrollment.objects(course_id=course_id, student_id=student_id).first()\n            if existing:\n                return {'success': False, 'error': 'Student already enrolled'}\n            \n            # Create enrollment\n            enrollment_data = {\n                'course_id': course_id,\n                'student_id': student_id,\n                'student_name': student_name or 'Unknown',\n                'student_email': student_email or '',\n                'university': kwargs.get('university', ''),\n                'import_source': kwargs.get('import_source', 'manual'),\n                'import_batch_id': kwargs.get('import_batch_id'),\n                'external_id': kwargs.get('external_id')\n            }\n            \n            enrollment = CourseEnrollment(**enrollment_data)\n            enrollment.save()\n            \n            # Update course enrollment count\n            course.current_enrollment += 1\n            course.save()\n            \n            return {'success': True, 'enrollment': enrollment}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def import_students_from_csv(course_id, csv_content, imported_by, filename=None):\n        \"\"\"Import students from CSV with duplicate prevention and error tracking\"\"\"\n        try:\n            # Create import log\n            batch_id = str(uuid.uuid4())\n            import_log = StudentImportLog(\n                course_id=course_id,\n                batch_id=batch_id,\n                imported_by=imported_by,\n                import_type='csv',\n                original_filename=filename,\n                file_size=len(csv_content)\n            )\n            import_log.save()\n            \n            # Parse CSV\n            csv_reader = csv.DictReader(io.StringIO(csv_content))\n            \n            results = {\n                'total_records': 0,\n                'successful_imports': 0,\n                'failed_imports': 0,\n                'duplicate_records': 0,\n                'errors': []\n            }\n            \n            row_number = 0\n            for row in csv_reader:\n                row_number += 1\n                results['total_records'] += 1\n                \n                try:\n                    # Validate required fields\n                    if not row.get('student_id'):\n                        error = ImportError(\n                            import_log_id=str(import_log.id),\n                            row_number=row_number,\n                            student_data=dict(row),\n                            error_type='missing_field',\n                            error_message='Missing student_id'\n                        )\n                        error.save()\n                        results['failed_imports'] += 1\n                        results['errors'].append({\n                            'row': row_number,\n                            'error': 'Missing student_id',\n                            'data': dict(row)\n                        })\n                        continue\n                    \n                    # Check for duplicates\n                    existing = CourseEnrollment.objects(\n                        course_id=course_id, \n                        student_id=row['student_id']\n                    ).first()\n                    \n                    if existing:\n                        error = ImportError(\n                            import_log_id=str(import_log.id),\n                            row_number=row_number,\n                            student_data=dict(row),\n                            error_type='duplicate',\n                            error_message=f'Student {row[\"student_id\"]} already enrolled'\n                        )\n                        error.save()\n                        results['duplicate_records'] += 1\n                        results['errors'].append({\n                            'row': row_number,\n                            'error': f'Student {row[\"student_id\"]} already enrolled',\n                            'data': dict(row)\n                        })\n                        continue\n                    \n                    # Enroll student\n                    enrollment_result = EnrollmentService.enroll_student(\n                        course_id=course_id,\n                        student_id=row['student_id'],\n                        student_name=row.get('student_name', ''),\n                        student_email=row.get('email', ''),\n                        university=row.get('university', ''),\n                        external_id=row.get('external_id', ''),\n                        import_source='csv',\n                        import_batch_id=batch_id\n                    )\n                    \n                    if enrollment_result['success']:\n                        results['successful_imports'] += 1\n                    else:\n                        error = ImportError(\n                            import_log_id=str(import_log.id),\n                            row_number=row_number,\n                            student_data=dict(row),\n                            error_type='validation_error',\n                            error_message=enrollment_result['error']\n                        )\n                        error.save()\n                        results['failed_imports'] += 1\n                        results['errors'].append({\n                            'row': row_number,\n                            'error': enrollment_result['error'],\n                            'data': dict(row)\n                        })\n                \n                except Exception as e:\n                    error = ImportError(\n                        import_log_id=str(import_log.id),\n                        row_number=row_number,\n                        student_data=dict(row),\n                        error_type='processing_error',\n                        error_message=str(e)\n                    )\n                    error.save()\n                    results['failed_imports'] += 1\n                    results['errors'].append({\n                        'row': row_number,\n                        'error': str(e),\n                        'data': dict(row)\n                    })\n            \n            # Update import log\n            import_log.total_records = results['total_records']\n            import_log.successful_imports = results['successful_imports']\n            import_log.failed_imports = results['failed_imports']\n            import_log.duplicate_records = results['duplicate_records']\n            import_log.status = 'completed'\n            import_log.completed_at = datetime.utcnow()\n            import_log.save()\n            \n            results['import_log_id'] = str(import_log.id)\n            results['batch_id'] = batch_id\n            \n            return {'success': True, 'results': results}\n        \n        except Exception as e:\n            # Update import log with error\n            if 'import_log' in locals():\n                import_log.status = 'failed'\n                import_log.error_message = str(e)\n                import_log.completed_at = datetime.utcnow()\n                import_log.save()\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def get_course_students(course_id, page=1, per_page=50, filters=None):\n        \"\"\"Get students enrolled in course with pagination\"\"\"\n        try:\n            query = Q(course_id=course_id)\n            \n            # Apply filters\n            if filters:\n                if filters.get('status'):\n                    query &= Q(status=filters['status'])\n                if filters.get('university'):\n                    query &= Q(university=filters['university'])\n                if filters.get('search'):\n                    search = filters['search']\n                    query &= (Q(student_name__icontains=search) | \n                             Q(student_email__icontains=search) | \n                             Q(student_id__icontains=search))\n            \n            # Calculate offset\n            offset = (page - 1) * per_page\n            \n            # Get total count\n            total = CourseEnrollment.objects(query).count()\n            \n            # Get enrollments\n            enrollments = CourseEnrollment.objects(query).order_by('-enrollment_date').skip(offset).limit(per_page)\n            \n            return {\n                'success': True,\n                'students': enrollments,\n                'pagination': {\n                    'page': page,\n                    'per_page': per_page,\n                    'total': total,\n                    'pages': (total + per_page - 1) // per_page\n                }\n            }\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def export_students_csv(course_id, include_errors=False, import_log_id=None):\n        \"\"\"Export students or import errors to CSV\"\"\"\n        try:\n            output = io.StringIO()\n            \n            if include_errors and import_log_id:\n                # Export import errors\n                errors = ImportError.objects(import_log_id=import_log_id)\n                if errors:\n                    # Get field names from first error's student data\n                    first_error = errors.first()\n                    fieldnames = list(first_error.student_data.keys()) + ['error_type', 'error_message', 'row_number']\n                    \n                    writer = csv.DictWriter(output, fieldnames=fieldnames)\n                    writer.writeheader()\n                    \n                    for error in errors:\n                        row_data = dict(error.student_data)\n                        row_data.update({\n                            'error_type': error.error_type,\n                            'error_message': error.error_message,\n                            'row_number': error.row_number\n                        })\n                        writer.writerow(row_data)\n            else:\n                # Export enrolled students\n                enrollments = CourseEnrollment.objects(course_id=course_id)\n                \n                fieldnames = ['student_id', 'student_name', 'student_email', 'enrollment_date', \n                             'status', 'progress_percentage', 'university', 'external_id']\n                \n                writer = csv.DictWriter(output, fieldnames=fieldnames)\n                writer.writeheader()\n                \n                for enrollment in enrollments:\n                    writer.writerow({\n                        'student_id': enrollment.student_id,\n                        'student_name': enrollment.student_name,\n                        'student_email': enrollment.student_email,\n                        'enrollment_date': enrollment.enrollment_date.strftime('%Y-%m-%d %H:%M:%S'),\n                        'status': enrollment.status,\n                        'progress_percentage': enrollment.progress_percentage,\n                        'university': enrollment.university,\n                        'external_id': enrollment.external_id\n                    })\n            \n            return {'success': True, 'csv_content': output.getvalue()}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def get_enrolled_courses(student_id, page=1, per_page=20):\n        \"\"\"Get courses student is enrolled in\"\"\"\n        try:\n            query = Q(student_id=student_id)\n            offset = (page - 1) * per_page\n            total = CourseEnrollment.objects(query).count()\n            \n            enrollments = CourseEnrollment.objects(query).order_by('-enrollment_date').skip(offset).limit(per_page)\n            \n            # Get course details\n            courses_data = []\n            for enrollment in enrollments:\n                course = Course.objects(id=enrollment.course_id).first()\n                if course:\n                    courses_data.append({\n                        'enrollment': enrollment,\n                        'course': course\n                    })\n            \n            return {\n                'success': True,\n                'courses': courses_data,\n                'pagination': {\n                    'page': page,\n                    'per_page': per_page,\n                    'total': total,\n                    'pages': (total + per_page - 1) // per_page\n                }\n            }\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def update_student_progress(course_id, student_id, progress_percentage):\n        \"\"\"Update student progress in course\"\"\"\n        try:\n            enrollment = CourseEnrollment.objects(course_id=course_id, student_id=student_id).first()\n            if not enrollment:\n                return {'success': False, 'error': 'Enrollment not found'}\n            \n            enrollment.progress_percentage = progress_percentage\n            if progress_percentage >= 100:\n                enrollment.status = 'completed'\n                enrollment.completion_date = datetime.utcnow()\n            \n            enrollment.save()\n            return {'success': True, 'enrollment': enrollment}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n\n\nclass MaterialService:\n    \"\"\"Service class for course material management\"\"\"\n    \n    @staticmethod\n    def upload_material(course_id, file, title, uploaded_by, **kwargs):\n        \"\"\"Upload course material\"\"\"\n        try:\n            # Validate course access\n            course = Course.objects(id=course_id, instructor_id=uploaded_by).first()\n            if not course:\n                return {'success': False, 'error': 'Course not found or access denied'}\n            \n            # Generate secure filename\n            filename = secure_filename(file.filename)\n            file_extension = filename.rsplit('.', 1)[1].lower() if '.' in filename else ''\n            \n            # Create upload directory if not exists\n            upload_dir = f'uploads/courses/{course_id}/materials'\n            os.makedirs(upload_dir, exist_ok=True)\n            \n            # Save file\n            file_path = os.path.join(upload_dir, filename)\n            file.save(file_path)\n            \n            # Create material record\n            material_data = {\n                'course_id': course_id,\n                'title': title,\n                'description': kwargs.get('description', ''),\n                'file_name': filename,\n                'file_path': file_path,\n                'file_size': os.path.getsize(file_path),\n                'file_type': file_extension,\n                'mime_type': file.content_type,\n                'category': kwargs.get('category', 'other'),\n                'module_id': kwargs.get('module_id'),\n                'uploaded_by': uploaded_by,\n                'is_published': kwargs.get('is_published', False),\n                'available_from': kwargs.get('available_from'),\n                'available_until': kwargs.get('available_until')\n            }\n            \n            material = CourseMaterial(**material_data)\n            material.save()\n            \n            return {'success': True, 'material': material}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def get_course_materials(course_id, page=1, per_page=20, filters=None, user_id=None, user_role=None):\n        \"\"\"Get course materials with access control\"\"\"\n        try:\n            query = Q(course_id=course_id)\n            \n            # Apply visibility filters based on user role\n            if user_role != 'teacher':\n                query &= Q(is_published=True)\n                # Check availability dates\n                now = datetime.utcnow()\n                query &= (Q(available_from__lte=now) | Q(available_from=None))\n                query &= (Q(available_until__gte=now) | Q(available_until=None))\n            \n            # Apply additional filters\n            if filters:\n                if filters.get('category'):\n                    query &= Q(category=filters['category'])\n                if filters.get('file_type'):\n                    query &= Q(file_type=filters['file_type'])\n                if filters.get('module_id'):\n                    query &= Q(module_id=filters['module_id'])\n                if filters.get('search'):\n                    search = filters['search']\n                    query &= (Q(title__icontains=search) | Q(description__icontains=search))\n            \n            # Calculate offset\n            offset = (page - 1) * per_page\n            \n            # Get total count\n            total = CourseMaterial.objects(query).count()\n            \n            # Get materials\n            materials = CourseMaterial.objects(query).order_by('order', '-uploaded_at').skip(offset).limit(per_page)\n            \n            return {\n                'success': True,\n                'materials': materials,\n                'pagination': {\n                    'page': page,\n                    'per_page': per_page,\n                    'total': total,\n                    'pages': (total + per_page - 1) // per_page\n                }\n            }\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def download_material(material_id, user_id, ip_address=None, user_agent=None):\n        \"\"\"Download material with access logging\"\"\"\n        try:\n            material = CourseMaterial.objects(id=material_id).first()\n            if not material:\n                return {'success': False, 'error': 'Material not found'}\n            \n            # Check if file exists\n            if not os.path.exists(material.file_path):\n                return {'success': False, 'error': 'File not found on server'}\n            \n            # Log download\n            download_log = MaterialDownloadLog(\n                material_id=material_id,\n                course_id=material.course_id,\n                downloaded_by=user_id,\n                ip_address=ip_address,\n                user_agent=user_agent\n            )\n            download_log.save()\n            \n            # Update download count\n            material.download_count += 1\n            material.save()\n            \n            return {'success': True, 'file_path': material.file_path, 'filename': material.file_name}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def delete_material(material_id, user_id):\n        \"\"\"Delete material (instructor only)\"\"\"\n        try:\n            material = CourseMaterial.objects(id=material_id, uploaded_by=user_id).first()\n            if not material:\n                return {'success': False, 'error': 'Material not found or access denied'}\n            \n            # Delete file from filesystem\n            if os.path.exists(material.file_path):\n                os.remove(material.file_path)\n            \n            # Delete from database\n            material.delete()\n            \n            return {'success': True, 'message': 'Material deleted successfully'}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n\n\nclass AnnouncementService:\n    \"\"\"Service class for course announcements\"\"\"\n    \n    @staticmethod\n    def create_announcement(course_id, title, content, created_by, created_by_name=None, **kwargs):\n        \"\"\"Create course announcement\"\"\"\n        try:\n            # Validate course access\n            course = Course.objects(id=course_id, instructor_id=created_by).first()\n            if not course:\n                return {'success': False, 'error': 'Course not found or access denied'}\n            \n            announcement_data = {\n                'course_id': course_id,\n                'title': title,\n                'content': content,\n                'created_by': created_by,\n                'created_by_name': created_by_name or 'Unknown',\n                'is_pinned': kwargs.get('is_pinned', False),\n                'is_urgent': kwargs.get('is_urgent', False),\n                'priority': kwargs.get('priority', 2),\n                'publish_at': kwargs.get('publish_at'),\n                'expire_at': kwargs.get('expire_at'),\n                'attachment_ids': kwargs.get('attachment_ids', [])\n            }\n            \n            announcement = CourseAnnouncement(**announcement_data)\n            announcement.save()\n            \n            return {'success': True, 'announcement': announcement}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def get_course_announcements(course_id, page=1, per_page=10, user_role=None):\n        \"\"\"Get course announcements with filtering\"\"\"\n        try:\n            query = Q(course_id=course_id)\n            \n            # Apply visibility filters for students\n            if user_role != 'teacher':\n                now = datetime.utcnow()\n                query &= (Q(publish_at__lte=now) | Q(publish_at=None))\n                query &= (Q(expire_at__gte=now) | Q(expire_at=None))\n            \n            # Calculate offset\n            offset = (page - 1) * per_page\n            \n            # Get total count\n            total = CourseAnnouncement.objects(query).count()\n            \n            # Get announcements (pinned first, then by date)\n            announcements = CourseAnnouncement.objects(query).order_by('-is_pinned', '-created_at').skip(offset).limit(per_page)\n            \n            return {\n                'success': True,\n                'announcements': announcements,\n                'pagination': {\n                    'page': page,\n                    'per_page': per_page,\n                    'total': total,\n                    'pages': (total + per_page - 1) // per_page\n                }\n            }\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def update_announcement(announcement_id, user_id, update_data):\n        \"\"\"Update announcement (instructor only)\"\"\"\n        try:\n            announcement = CourseAnnouncement.objects(id=announcement_id, created_by=user_id).first()\n            if not announcement:\n                return {'success': False, 'error': 'Announcement not found or access denied'}\n            \n            # Update allowed fields\n            allowed_fields = ['title', 'content', 'is_pinned', 'is_urgent', 'priority', 'publish_at', 'expire_at']\n            \n            for field in allowed_fields:\n                if field in update_data:\n                    setattr(announcement, field, update_data[field])\n            \n            announcement.save()\n            return {'success': True, 'announcement': announcement}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def delete_announcement(announcement_id, user_id):\n        \"\"\"Delete announcement (instructor only)\"\"\"\n        try:\n            announcement = CourseAnnouncement.objects(id=announcement_id, created_by=user_id).first()\n            if not announcement:\n                return {'success': False, 'error': 'Announcement not found or access denied'}\n            \n            announcement.delete()\n            return {'success': True, 'message': 'Announcement deleted successfully'}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n\n\nclass TeacherToolsService:\n    \"\"\"Comprehensive service for teacher-specific tools and analytics\"\"\"\n    \n    @staticmethod\n    def get_dashboard_stats(instructor_id):\n        \"\"\"Get comprehensive dashboard statistics for teacher\"\"\"\n        try:\n            # Get instructor's courses\n            courses = Course.objects(instructor_id=instructor_id)\n            course_ids = [str(course.id) for course in courses]\n            \n            # Get enrollment statistics\n            total_enrollments = CourseEnrollment.objects(course_id__in=course_ids).count()\n            active_students = CourseEnrollment.objects(course_id__in=course_ids, status='enrolled').count()\n            \n            # Get material statistics\n            total_materials = CourseMaterial.objects(course_id__in=course_ids).count()\n            total_downloads = sum([m.download_count for m in CourseMaterial.objects(course_id__in=course_ids)])\n            \n            # Get announcement statistics\n            total_announcements = CourseAnnouncement.objects(course_id__in=course_ids).count()\n            \n            # Recent activity\n            recent_enrollments = CourseEnrollment.objects(\n                course_id__in=course_ids\n            ).order_by('-enrollment_date').limit(10)\n            \n            recent_downloads = MaterialDownloadLog.objects(\n                course_id__in=course_ids\n            ).order_by('-downloaded_at').limit(10)\n            \n            stats = {\n                'courses': {\n                    'total': courses.count(),\n                    'published': courses.filter(is_published=True).count(),\n                    'active': courses.filter(is_active=True).count()\n                },\n                'students': {\n                    'total_enrollments': total_enrollments,\n                    'active_students': active_students,\n                    'completed': CourseEnrollment.objects(course_id__in=course_ids, status='completed').count()\n                },\n                'materials': {\n                    'total': total_materials,\n                    'total_downloads': total_downloads,\n                    'published': CourseMaterial.objects(course_id__in=course_ids, is_published=True).count()\n                },\n                'announcements': {\n                    'total': total_announcements,\n                    'pinned': CourseAnnouncement.objects(course_id__in=course_ids, is_pinned=True).count()\n                },\n                'recent_activity': {\n                    'enrollments': recent_enrollments,\n                    'downloads': recent_downloads\n                }\n            }\n            \n            return {'success': True, 'stats': stats}\n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    @staticmethod\n    def get_import_history(instructor_id, course_id=None, page=1, per_page=20):\n        \"\"\"Get import history for instructor\"\"\"\n        try:\n            query = Q(imported_by=instructor_id)\n            if course_id:\n                query &= Q(course_id=course_id)\n            \n            offset = (page - 1) * per_page\n            total = StudentImportLog.objects(query).count()\n            \n            import_logs = StudentImportLog.objects(query).order_by('-started_at').skip(offset).limit(per_page)\n            \n            return {\n                'success': True,\n                'import_logs': import_logs,\n                'pagination': {\n                    'page': page,\n                    'per_page': per_page,\n                    'total': total,\n                    'pages': (total + per_page - 1) // per_page\n                }\n            }\n        except Exception as e:\n            return {'success': False, 'error': str(e)}
